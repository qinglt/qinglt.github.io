[{"title":"JVM","url":"/posts/66c016fb/","content":"\n![image-20220429205418010](../images/image-20220429205418010.png)","tags":["八股文"],"categories":["Java"]},{"title":"Vuex学习","url":"/posts/413c71da/","content":"\n![logo](../images/logo.png)\n\n## 什么是vuex？\n\nVuex 是专门为 Vue.js 设计的状态管理库，采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n简单地说就是采用全局单例模式，将组件的共享状态抽离出来管理，使组件树中的每一个位置都可以获取共享的状态（变量）或者触发行为。\n\n额，或者更直白的说就是响应式的全局变量\n\n \n\n## vuex核心概念\n\n| State    | 共享状态（即变量）                                           |\n| -------- | ------------------------------------------------------------ |\n| Getter   | 基于state的派生状态，可理解为组件中的计算属性                |\n| Mutation | 更改vuex的store中状态的唯一方法，通过提交mutation修改状态，同步操作（规则上是不允许异步操作的，虽然异步也可以执行，但是对devtool调试的状态跟踪或多个状态更改操作相互依赖是很不好的，所以不要觉得只要不报错我就可以这么用，还是尽量按照规则来比较好） |\n| Action   | 类似mutation，不同之处，1.通过提交mutation修改状态  2.支持异步操作 |\n| Module   | 模块，在大型项目中为了方便状态的管理和协作开发将store拆分为多个子模块（modules），每个子模块拥有完整的state、mutation、action、getter |\n\n \n\n## vuex安装与使用\n\n1.安装vuex（命令）\n\n```\nnpm install vuex --save     // 如果安装了淘宝镜像，可以使用 cnpm安装\n```","tags":["Vuex"],"categories":["Vue"]},{"title":"git常用命令","url":"/posts/423abe9e/","content":"\n# 撤销对文件的修改\n\n```\ngit checkout --  index.html\n```\n\n\n\n# 取消暂存的文件\n\n```\ngit reset HEAD index.html\n\ngit reset HEAD .\n```\n\n\n\n# 跳过暂存区直接提交到仓库\n\n```\ngit commit -a -m \"描述信息\"\n```\n\n\n\n# 查看已加入本地仓库的文件\n\n```\ngit ls-files\n```\n\n\n\n\n# 移除文件\n\n### 从git仓库和工作区间同时移除index.html文件\n\n```\ngit rm -f index.html\n```\n\n\n\n### 只从git仓库中移除index.html 但保留工作区中的 index.html\n\n```\ngit rm --cached index.html\n```\n\n\n\n## 删除test文件夹流程\n\n```\n1.将远程仓库里面的项目拉下来\n\n$git pull origin main\n\n2.删除test文件夹\n\n$git rm -f --cached test\n\n4.提交，添加说明\n\n$git commit -m \"删除test\"\n\n5.将本次更改更新到远程仓库\n\n$git push\n```\n\n\n\n# 忽略文件.gitignore\n\n```\n1.以#开头的是注释\n\n2.以/结尾的是目录\n\n3.以/开头的是防止递归\n\n4.以!开头的是表示取反\n\n5.可以使用glob模式进行文件夹和文件的匹配\n```\n\n\n\n## glob模式是指简化可的正则表达式\n\n```\n1.星号* 2.[abc] 3.问号? 4.两个星号**\n```\n\n\n\n## .gitignore文件的例子\n\n```\n#忽略所有的.a文件\n\n*.a\n\n#但跟踪所有的lib.a文件，即使你在前面忽略了.a文件\n\n!lib.a\n\n#只忽略当前目录下的TODO文件，而不忽略subdir/TODO\n\n/TODO \n\n#忽略任何目录下名为build的文件夹\n\nbuild/\n\n#忽略doc/notes/txt ，但不忽略 doc/server/arch.txt\n\ndoc/*.txt\n\n#忽略doc/目录及其所有子目录下的.pdf文件\n\ndoc/**/*.pdf\n```\n\n\n\n# 查看提交历史\n\n> 按时间先后顺序列出所有的提交历史，最近的提交排在最上面\n\n```\ngit log\n```\n\n\n\n> 只展示最新的两条提交历史,数字可以按需填写\n\n```\ngit log -2\n```\n\n\n\n> 在一行上展示最近两条提交的历史信息\n\n```\ngit log -2 --pretty=oneline\n```\n\n\n\n### 在一行上展示最近的两条提交历史信息,并自定义输出的格式\n\n>  %h 提交的简写哈希值 %an 作者名字  %ar 作者修订日期，按多久以前的方式显示  %s 提交说明 \n\n```\ngit log -2 --pretty=format:\"%h | %an | %ar | %s\"\n```\n\n\n\n\n# 回退到指定的版本\n\n### 在一行上展示所有的提交历史\n\n```\ngit log --pretty=oneline\n```\n\n\n\n### 使用git reset --hard 命令，根据指定的提交ID 回退到指定的版本\n\n```\ngit reset --hard <CommitID>\n```\n\n\n\n### 在旧版本中使用 git reflog --pretty=oneline 命令，查看命令操作的历史\n\n```\ngit reflog --pretty=oneline\n```\n\n\n\n### 再次根据最新的提交ID 跳转到最新的版本\n\n```\ngit reset --hard <CommitID>\n```\n\n\n\n\n# 分支\n\n主分支上不进行代码开发，已经开发完成的功能分支会在合并后结束生命\n\n\n\n## 查看所有分支的命令\n\n```\ngit branch   -a\n\n所在分支前会有*标识\n```\n\n\n\n## 创建分支\n\n```\ngit branch 分支名\n\n执行完后  还是处在当前分支，并未到达新建分支 \n```\n\n\n\n## 切换分支 \n\n```\ngit branch 分支名\n```\n\n\n\n## 分支的快速创建和切换\n\n```\ngit checkout -b 分支名\n\n实际就是是  git branch 分支名  git branch 分支名  这两条命令的合并\n\n创建分支时总是以主分支为基础来进行创建和切换分支 \n```\n\n\n\n# 合并分支\n\n```\n1.先切换到main分支：git checkout main\n\n2.在main上运行git merge test命令 将test 分支上的代码合并到main分支\n```\n\n\n\n# 删除本地分支\n\n```\ngit branch -d 分支名\n```\n\n\n\n# 遇到冲突时的分支合并\n\n```\n1。假设在test分支合并到main期间，代码发生了冲突\n\ngit checkout main\n\ngit merge test\n\n\n\n\n\n2.打开包含冲突的文件，手动解决后，再执行如下命令\n\ngit add .\n\ngit commit -m \"解决了分支合并冲突的问题\"\n```\n\n\n\n\n\n# 远程分支操作\n\n## 第一次把本地分支推送到远程仓库，需要运行如下命令\n\n### 只在第一次推送的时候需要加 -u 参数：-u 表示把本地分支和远程分支进行关联\n\n```\ngit  push -u  远程仓库名别名  本地分支名:远程分支名\n```\n\n\n\n###  实操\n\n```\ngit push -u origin payment:pay\n```\n\n\n\n### 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化：\n\n```\ngit push -u origin payment \n```\n\n\n\n\n\n# 查看远程仓库中所有的分支列表\n\n```\ngit remote show 远程仓库名\n```\n\n\n\n# 跟踪分支\n\n### 是指从远程仓库中 ，把远程分支下载到本地仓库中。命令如下：\n\n```\n1.把对应的而远程分支下载到本地仓库，保持本地分支和远程分支名称相同：\n\ngit checkout  远程分支名     示例： git  checkout  pay\n\n2.把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名：\n\ngit  checkout  -b  本地分支名  远程仓库名/远程分支名\n\n示例：git  checkout -b payment  origin/pay\n```\n\n\n\n\n\n# 拉取远程分支最新代码\n\n```\ngit  pull \n\n更新当前分支与远程 分支保持一致\n```\n\n\n\n# 删除远程仓库指定分支\n\n```\ngit  push   远程仓库名 --delete  远程分支名称\n\n示例：git  push  origin  --delete pay\n```\n\n\n\n### 删除本地分支\n\n```\ngit branch -d 分支名\n\n没被合并的分支 在执行删除操作时会报error    run'git branch -D 分支名'\n```\n\n\n","tags":["git"],"categories":["Java"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"Redis学习","url":"/posts/8434e219/","content":"\n# 1、String\n\n```bash\nappend key \"字符串\" # 向key后追加一个字符串，如果当前key不存在，就相当于set\n\nstrlen key # 获取字符串长度\n\nincr key # 加一\n\ndecr key # 自减1\n\nincrby value #增加value，可以设置步长，指定增量\n\ndecrby value # 减少value\n\n############################################################\n字符串范围 range \n\ngetrange key start end # 下标从0开始，start-end\ngetrange key 0 -1 # 查看整个字符串,获取全部字符串，和get key是一样的\n\n# 替换\n# 替换指定位置开始的字符串\nsetrange key offset string # offset：偏移量，string：要替换的字符串\n\n###########################################################\n# setex(set with expire) # 设置过期时间\n\n# setnx(set if not exist) # 不存在设置，在分布式锁中会经常使用，保证当前这个值存在\n127.0.0.1:6379> setex key3 30 hello  # 设置key3的值30s后过期\nOK\n127.0.0.1:6379> ttl key3\n(integer) 27\n127.0.0.1:6379> get key3\n\"hello\"\n127.0.0.1:6379> setnx mykey \"redis\" # 如果mykey不存在，创建mykey\n(integer) 1\n127.0.0.1:6379> keys *\n1) \"mykey\"\n2) \"key2\"\n3) \"key1\"\n127.0.0.1:6379> ttl key3\n(integer) -2\n127.0.0.1:6379> setnx mykey \"MongoDB\" # 如果mykey存在，则创建失败\n(integer) 0\n127.0.0.1:6379> get mykey\n\"redis\"\n########################################################\n# 批量set，get\nmset k1 v1 k2 v2 ... # 同时设置多个值\n\nmget k1 k2 ... # 同时获取多个值\n\nmsetnx k1 v1 k2 v2 ... # msetnx是一个原子性的操作，要么一起成功，要么一起失败\n\n# 对象\nset user:1 {name:zhangsan,age:3} # 设置一个user:1对象，值为json字符串来保存一个对象\n\nmset user:1:name zhangsan user:1:age 20 # 这里的key是一个巧妙的设计，user:{id}:{field}，如此设计在redis中是完全可以的\n\ngetset # 先get后se\ngetset key value # 如果不存在值则返回nil，如果存在值则获取原来的值，然后set\n```\n\n## String类似的使用场景：value除了是我们的字符串还可以是数字\n\n计数器\n统计多单位的数量 uid\n粉丝数\n对象缓存存储\n\n# 2、list\n\n基本的数据类型，列表\n\n在redis里面，我们可以把list玩成栈，队列\n\n所有的list命令都是用l来开头的，不区分大小写命令\n\n```bash\n127.0.0.1:6379> lpush list one # 将一个值或多个值插入到列表的头部\n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> lrange list 0 -1 # 获取所有元素\n1) \"three\"\n2) \"two\"\n3) \"one\"\n127.0.0.1:6379> lrange list 0 1 # 获取0-1，通过区间获取具体的值\n1) \"three\"\n2) \"two\"\n127.0.0.1:6379> rpush list right # 将一个值放在链表的尾部\n(integer) 4\n127.0.0.1:6379> lrange list  0  -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n4) \"right\"\n\n##############################################################\n\nlpop key # 移除列表的第一个元素\nrpop key # 移除列表的最后一个元素\n\nlindex key index # 获取key的index下标处的值，index从0开始\n\nllen key # 获取list的长度\n\n# 移除指定的值\nlrme key count value # 删除count个value，从前往后删除，精确匹配\n\n#############################################################\ntrim 修剪操作：list截断\nltrim key start stop # 截取list的start到stop之间的所有元素，左右都闭合，这个list就已经被改变了，只剩下截取的元素\n\nrpoplpush source destination # 移除列表的最后一个元素并添加到目的列表的第一个\n\nexists key # 判断里面有没有值\n\nlset key index element # 设置key的index下标位置的值为element ，只有存在这个index下标才可以使用\n\nlinsert key before|after pivot element # 在pivot之前或之后插入值\n```\n\n## 小结：\n\nlist实际上一个链表，before Node after，左右都可以插入\n如果key不存在，创建新的链表\n如果存在，新增内容\n如果移除了所有值，空链表，不存在\n在两边改动效率最高，中间元素效率会低一点\n**消息排队！消息队列，**\n\n# 3、Set\n\n**set中的值是不能重复的**\n\n```bash\nsadd key value # 向set集合中添加\n\nsmembers key # 查看key里面的所有值\n\nscard key # 获取set的元素个数\n\nsismember key value # 判断value值是否在key中\n\nsrem key value # 移除value元素\n\nset # 无序不重复集合，抽随机\n\nsrandmember myset count # 随机抽出指定个数元素\n\nspop key count # 随机删除一些set集合中的元素\n\nsmove source destination # 将一个集合中的元素移动到另一个集合中\n\n数字集合类：\n - 差集 sdiff key1 key2\n - 交集 sinter key1 key2 # 共同好友就可以这样实现\n - 并集 sunion key1 key2 \n```\n\n## 使用场景\n\n共同关注，共同爱好，二度好友\n\n# 4、Hsah\n\nMap集合，key-,key-map,这时候这个值是一个map集合，本质和string没有太大区别\n\n```bash\nhset key filed value [field value] # 存放hash As of Redis 4.0.0, HSET is variadic and allows for multiple field/value pairs.\n# As per Redis 4.0.0, HMSET is considered deprecated. Please use HSET in new code.\n\nhget key field # 获取key中filed键的值\n\nhgetall key # 获取所有的键值对\n\nhdel key filed # 删除hash指定的字段，对应的value也就没有了\n\nhlen key # 获取hash的内容长度\n\nhexists key field # 判断hash中的某个filed是否存在\n\nhkeys key # 获取hash的所有键（key）\n\nhvals key # 获取hash的所有值\n\nhincrby key filed count # 自增count\n\nhdecrby key field count  # 自减\n```\n\n# 5、Zset（有序集合）\n\n在set的基础上，增加了一个值, zset k1 score1 v1zadd key score value # 添加值，score代表优先级，可以一次添加多个\n\n```bash\nzrange key start end # 获取start-end的值，0 -1代表获取所有值\n\n# 排序如何实现\nzrangebyscore key startscore endscore # 对集合通过score排序， 默认升序\n\nzrangebyscore key -inf inf withscores # 显示score\n\nzrevrange salary 0 -1 [withscores] # 降序排列所有值\n\nzrem key member [member] # 移除元素\n\nzcard key # 获取有序集合中的个数\n\nzcount key start end # 获取start-end之间的个数\n```\n\n## 多查官方文档\n\n案例思路：set 排序 存储班级成绩表，工资表排序\n\n普通消息：1.重要消息 2.带权重进行判断\n\n排行榜应用实现，取top n测试"},{"title":"异步、定时、邮件任务","url":"/posts/a60ba49d/","content":"\n异步任务\n1、创建一个service包\n\n2、创建一个类AsyncService\n\n异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。\n\n编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；\n\n```java\n@Service\npublic class AsyncService {\n\n   public void hello(){\n       try {\n           Thread.sleep(3000);\n      } catch (InterruptedException e) {\n           e.printStackTrace();\n      }\n       System.out.println(\"业务进行中....\");\n  }\n}\n```\n\n3、编写controller包\n\n4、编写AsyncController类\n\n我们去写一个Controller测试一下\n\n```java\n@RestController\npublic class AsyncController {\n\n   @Autowired\n   AsyncService asyncService;\n\n   @GetMapping(\"/hello\")\n   public String hello(){\n       asyncService.hello();\n       return \"success\";\n  }\n\n}\n```\n\n5、访问[http://localhost](http://localhost/):8080/hello进行测试，3秒后出现success，这是同步等待的情况。\n\n问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：\n\n6、给hello方法添加@Async注解；\n\n```java\n//告诉Spring这是一个异步方法\n@Async\npublic void hello(){\n   try {\n       Thread.sleep(3000);\n  } catch (InterruptedException e) {\n       e.printStackTrace();\n  }\n   System.out.println(\"业务进行中....\");\n}\n```\n\nSpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；\n\n```java\n@EnableAsync //开启异步注解功能\n@SpringBootApplication\npublic class SpringbootTaskApplication {\n\n   public static void main(String[] args) {\n       SpringApplication.run(SpringbootTaskApplication.class, args);\n  }\n\n}\n```\n\n7、重启测试，网页瞬间响应，后台代码依旧执行！\n\n定时任务\n项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。\n\nTaskExecutor接口\n\nTaskScheduler接口\n\n两个注解：\n\n@EnableScheduling\n\n@Scheduled\n\ncron表达式：\n\n图片\n\n图片\n\n测试步骤：\n\n1、创建一个ScheduledService\n\n我们里面存在一个hello方法，他需要定时执行，怎么处理呢？\n\n```java\n@Service\npublic class ScheduledService {\n   \n   //秒   分   时     日   月   周几\n   //0 * * * * MON-FRI\n   //注意cron表达式的用法；\n   @Scheduled(cron = \"0 * * * * 0-7\")\n   public void hello(){\n       System.out.println(\"hello.....\");\n  }\n}\n```\n\n2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能\n\n```java\n@EnableAsync //开启异步注解功能\n@EnableScheduling //开启基于注解的定时任务\n@SpringBootApplication\npublic class SpringbootTaskApplication {\n\n   public static void main(String[] args) {\n       SpringApplication.run(SpringbootTaskApplication.class, args);\n  }\n\n}\n```\n\n3、我们来详细了解下cron表达式；\n\nhttp://www.bejson.com/othertools/cron/\n\n4、常用的表达式\n\n```\n（1）0/2     ?   表示每2秒 执行任务\n（1）0 0/2   * ?   表示每2分钟 执行任务\n（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务\n（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业\n（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n（4）0 0 10,14,16   ?   每天上午10点，下午2点，4点\n（5）0 0/30 9-17   ?   朝九晚五工作时间内每半小时\n（6）0 0 12 ? * WED   表示每个星期三中午12点\n（7）0 0 12   ?   每天中午12点触发\n（8）0 15 10 ?     每天上午10:15触发\n（9）0 15 10   ?     每天上午10:15触发\n（10）0 15 10   ?   每天上午10:15触发\n（11）0 15 10   ? 2005   2005年的每天上午10:15触发\n（12）0  *14*  * ?     在每天下午2点到下午2:59期间的每1分钟触发\n（13）0 0/5 14   ?   在每天下午2点到下午2:55期间的每5分钟触发\n（14）0 0/5 14,18   ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\n（15）0 0-5 14   ?   在每天下午2点到下午2:05期间的每1分钟触发\n（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发\n（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发\n（18）0 15 10 15 * ?   每月15日上午10:15触发\n（19）0 15 10 L * ?   每月最后一日的上午10:15触发\n（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发\n（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发\n（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发\n```\n\n邮件任务\n邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持\n\n邮件发送需要引入spring-boot-start-mail\n\nSpringBoot 自动配置MailSenderAutoConfiguration\n\n定义MailProperties内容，配置在application.yml中\n\n自动装配JavaMailSender\n\n测试邮件发送\n\n测试：\n\n1、引入pom依赖\n\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n看它引入的依赖，可以看到 jakarta.mail\n\n```xml\n<dependency>\n   <groupId>com.sun.mail</groupId>\n   <artifactId>jakarta.mail</artifactId>\n   <version>1.6.4</version>\n   <scope>compile</scope>\n</dependency>\n```\n\n2、查看自动配置类：MailSenderAutoConfiguration\n\n图片\n\n这个类中存在bean，JavaMailSenderImpl\n\n图片\n\n然后我们去看下配置文件\n\n```java\n@ConfigurationProperties(\n   prefix = \"spring.mail\"\n)\npublic class MailProperties {\n   private static final Charset DEFAULT_CHARSET;\n   private String host;\n   private Integer port;\n   private String username;\n   private String password;\n   private String protocol = \"smtp\";\n   private Charset defaultEncoding;\n   private Map<String, String> properties;\n   private String jndiName;\n}\n```\n\n3、配置文件：\n\n```yaml\nspring.mail.username=24736743@qq.com\nspring.mail.password=你的qq授权码\nspring.mail.host=smtp.qq.com\n# qq需要配置ssl\nspring.mail.properties.mail.smtp.ssl.enable=true\n```\n\n获取授权码：在QQ邮箱中的设置->账户->开启pop3和smtp服务\n\n图片\n\n4、Spring单元测试\n\n```java\n@Autowired\nJavaMailSenderImpl mailSender;\n\n@Test\npublic void contextLoads() {\n   //邮件设置1：一个简单的邮件\n   SimpleMailMessage message = new SimpleMailMessage();\n   message.setSubject(\"通知-明天来狂神这听课\");\n   message.setText(\"今晚7:30开会\");\n\n   message.setTo(\"24736743@qq.com\");\n   message.setFrom(\"24736743@qq.com\");\n   mailSender.send(message);\n}\n\n@Test\npublic void contextLoads2() throws MessagingException {\n   //邮件设置2：一个复杂的邮件\n   MimeMessage mimeMessage = mailSender.createMimeMessage();\n   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);\n\n   helper.setSubject(\"通知-明天来狂神这听课\");\n   helper.setText(\"<b style='color:red'>今天 7:30来开会</b>\",true);\n\n   //发送附件\n   helper.addAttachment(\"1.jpg\",new File(\"\"));\n   helper.addAttachment(\"2.jpg\",new File(\"\"));\n\n   helper.setTo(\"24736743@qq.com\");\n   helper.setFrom(\"24736743@qq.com\");\n\n   mailSender.send(mimeMessage);\n}\n```\n\n查看邮箱，邮件接收成功！\n\n我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！","tags":["SpringBoot"],"categories":["Java"]},{"title":"前端js打印table","url":"/posts/3af5528f/","content":"\n\nJs代码\n\n```javascript\n//打印表格\nvar idTmr;  \nfunction  getExplorer() {  \n    var explorer = window.navigator.userAgent ;  \n    //ie  \n    if (explorer.indexOf(\"MSIE\") >= 0) {\n            return 'ie';\n        }\n        //firefox  \n        else if (explorer.indexOf(\"Firefox\") >= 0) {\n            return 'Firefox';\n        }\n        //Chrome  \n        else if (explorer.indexOf(\"Chrome\") >= 0) {\n            return 'Chrome';\n        }\n        //Opera  \n        else if (explorer.indexOf(\"Opera\") >= 0) {\n            return 'Opera';\n        }\n        //Safari  \n        else if (explorer.indexOf(\"Safari\") >= 0) {\n            return 'Safari';\n        }\n    }\n    function method5(tableid) {\n        if (getExplorer() == 'ie') {\n            var curTbl = document.getElementById(tableid);\n            var oXL = new ActiveXObject(\"Excel.Application\");\n            var oWB = oXL.Workbooks.Add();\n            var xlsheet = oWB.Worksheets(1);\n            var sel = document.body.createTextRange();\n            sel.moveToElementText(curTbl);\n            sel.select();\n            sel.execCommand(\"Copy\");\n            xlsheet.Paste();\n            oXL.Visible = true;\n\n            try {\n                var fname = oXL.Application.GetSaveAsFilename(\"Excel.xls\",\n                        \"Excel Spreadsheets (*.xls), *.xls\");\n            } catch (e) {\n                print(\"Nested catch caught \" + e);\n            } finally {\n                oWB.SaveAs(fname);\n                oWB.Close(savechanges = false);\n                oXL.Quit();\n                oXL = null;\n                idTmr = window.setInterval(\"Cleanup();\", 1);\n            }\n\n        } else {\n            tableToExcel(tableid)\n        }\n    }\n    function Cleanup() {\n        window.clearInterval(idTmr);\n        CollectGarbage();\n    }\n    var tableToExcel = (function() {\n        var uri = 'data:application/vnd.ms-excel;base64,', template = '<html><head><meta charset=\"UTF-8\"></head><body><table  border=\"1\">{table}</table></body></html>', base64 = function(\n                s) {\n            return window.btoa(unescape(encodeURIComponent(s)))\n        }, format = function(s, c) {\n            return s.replace(/{(\\w+)}/g, function(m, p) {\n                return c[p];\n            })\n        }\n        return function(table, name) {\n            if (!table.nodeType)\n                table = document.getElementById(table)\n            var ctx = {\n                worksheet : name || 'Worksheet',\n                table : table.innerHTML\n            }\n            window.location.href = uri + base64(format(template, ctx))\n        }\n    })()\n```\n\n***末尾的括号不能省\\***","tags":["JavaScript"],"categories":["JavaScript"]}]